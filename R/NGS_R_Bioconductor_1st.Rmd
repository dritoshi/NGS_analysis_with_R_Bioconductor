RとBioconductorでNGS解析: 第1時限 Rの基礎
========================================================

## はじめに
この文章は統合データベース講習会：AJACSみちのく2「RとBioconductorを使ったNGS解析」の講義資料です。

この文章の著作権は二階堂愛にあります。ファイルのダウンロード、印刷、複製、大量の印刷は自由におこなってよいです。企業、アカデミアに関わらず講義や勉強会で配布してもよいです。ただし販売したり営利目的の集まりで使用してはいけません。ここで許可した行為について二階堂愛に連絡や報告する必要はありません。常に最新版を配布したいので**ネット上での再配布や転載は禁止**します。ネット上でのリンクはご自由にどうぞ。内容についての問い合わせはお気軽にメールしてください。

## 対象
ここでは、本講義を理解する上で知っておきたい、Rの基本的な使いかたについて解説する。対象とするのはプログラミング初心者でRを利用したことがない人が対象である。

## 準備
まずは R をインストールする。http://rstudio.org/ から、利用しているOSに適した RStudio をインストールする。起動や終了は普通のアプリケーションと同じである。起動したときに3つのペイン(ウィンドウ内にある小窓)が見えるが、左下の console という部分に、Rのプログラムを書き込んでいく。

試しに以下のように入力して同じ結果になれば準備は終了である。ただし、あなたの環境では ## は表示されないがそれで正常である。
```{r}
1 + 1
```

## 学習範囲
プログラミング言語を理解するときに必要なことは、以下の3つである。

- データ型とデータ構造を知る
- 基本の3つの処理の書きかたを理解する
- 自分が使う便利な機能(関数、パッケージ)を覚える

この文章では、この3つについて簡単に説明する。

## データ型
データ型 (data type) とはデータの形式のことを意味する。例えば数値や文字列、論理型などがある。
```{r}
x <- c()
x
y <- c(1, 2)
y
z <- c("ATG", "GCG", "CTG", "TTA")
z
b <- c(TRUE, FALSE)
b
```
### データ型の変換
異なるデータ型を行き来したい場合がある。多くのプログラムのエラーはここが原因となるため、データの型の変換方法と、型を調べる方法を理解することは重要である。
```{r}
y <- as.character(y)
y
as.numeric(y)
y
```
### 型の確認
```{r}
is(1)
is("1")
```

## データ構造
前項ではデータを格納する型について解説した。このデータを集めて、決まった構造でデータを束ねておくのがデータ構造 (data structure) である。プログラミング言語が決まったデータ構造を提供することで、様々な計算が楽にできるようになる。なぜなら、データの中身が違っても構造が同じことを利用し汎用的な計算機能(関数)を用意できるからである。また、言語側で、データ構造に対する計算の効率を最適化しておくことができ、ユーザはそのデータ構造さえ使っておけば、高速化などに配慮しなくても良くなる。プログラム言語の善し悪しはこのデータ構造とそれを処理する機能の善し悪しによって決まるとも言える。

ここではRの基本的なデータ構造, vector, list, matrix, data frame について述べる。
### vector
vector は1種類のデータ型からなる1次元データを格納するためのデータ構造である。
```{r}
x <- c(3,2,4,1)
x
```
### list
list は複数のデータ型からなる1次元データを格納することができるデータ構造である。例えば文字列型と数値を同時に格納できる。
```{r}
y <- list(3,2,4,1)
y
```
### matrix
matrix は1種類のデータ型からなる2次元データを格納するためのデータ構造である。いわゆる行列を表現することができる。
```{r}
z <- matrix(
  c(3,2,1, 2,0,1, 4,5,7, 1,3,3),
  nrow = 3
)
z
```
### data frame
data frame は複数のデータ型からなる2次元データを格納するためのデータ構造である。Excel などのスプレットシートをイメージすればよい。数値行列だけを持つ場合は、matrix のほうが data frame より高速である。

```{r}
d <- data.frame(
  first       = c(3,2,1),
  first.base  = c("A", "T", "G"),
  second      = c(4,5,7),
  second.base = c("C", "G", "C")
)
d
```
### データ構造を確認する
どんなデータ構造を利用しているかを確認する方法を述べる。自分が使っているデータ構造を理解しておかないと、プログラムのエラー(バグ)の原因となる。特定のデータ構造を前提としている機能を使うとき、データ構造や型が異なる場合は、自動的に型や構造を変換したり、エラーを出したりする。
```{r}
is(z)
is(d)
str(d)
```

### データにアクセスする
データ構造にデータを出し入れする方法を示す。行や列の各要素を示す番号を添字 (index) と呼ぶ。これを使ってデータを取り出したり、代入することが可能である。

まず vector の要素にアクセスする方法を示す。添字は一番左から1,2,3,... となる。プログラミング言語によっては、添字が 0 から始まるものもあるが、R は 1 であることに注意すること。
```{r}
x <- c(3,2,4,1)
x[1]
x[1] <- 4
x
x[1:2]
x[1:2] <- c(3,8)
x
```
次に list の要素にアクセスする方法を示す。
```{r}
x <- list(3,2,4,1)
x[[1]]
x[[2]] <- 5
x
```
次は、matrix の要素にアクセスする方法を示す。横方向が行、縦方向が列であり、これは数学の行列と同じである。

```{r}
x <- matrix(
  c(3,2,1,2,0,1,4,5,7,1,3,3),
  nrow = 3
)
x[1,]   # 1行目にアクセス
x[,2]   # 2列目にアクセス
x[3,2]  # 3行2列目にアクセス
x[3,2] <- 9 # 3行2列目に9を
x[3,]
```
最後に data frame の要素にアクセスする方法を示す。
```{r}
x <- data.frame(
  first       = c(3,2,1),
  first.base  = c("A", "T", "G"),
  second      = c(4,5,7),
  second.base = c("C", "G", "C")
)
x$first
x$first.base
x$first.base <- c("T", "C", "A")
x$first.base
```

## 3つの基本的な処理
プログラミング言語は基本的には3つの処理の組み合わせで実行される。ダイクストラの構造化プログラミング (Structured Programming) では、基本的な処理として3つの処理が挙げられている。

順次: 書かれた順番に処理していく
反復: 条件が満されるまで処理を繰り返す
分岐: 条件が成立する場合は実行する

順次処理については、これまでも示してきた通りなので割愛するが、Rの場合は文単位 (行ではない) で上から下へと順次処理される。

次に反復処理について示す。ここでは、*for* を利用した繰り返しの構文を示す。
```{r}
ans <- 0
for (i in 1:10) {
  ans <- ans + i
}
ans
```
次に *if* を使って条件によって処理を分岐してみる。
```{r}
odd  <- 0
even <- 0
for (i in 1:10) {
  if (i %% 2 == 0) {
    even <- even + i
  } else {
    odd <- odd + i
  }   
}
cat(even, odd, "\n")
```

### 関数
関数 (function) とは、便利な機能のひとかたまりにしたものである。プログラミング言語には様々な関数が定義されており、この関数の豊富さが言語の使い易さに深く関わっている。Rでは文字や数値の処理だけでなく、統計処理のための便利な関数が多数用意されている。関数は膨大にあるので、まず自分の使う関数だけを覚えておき、必要に応じてリファレンスや Web検索などで必要な関数を調べるのがお勧めである。

簡単な統計量を計算する関数を紹介する。
```{r}
x <- 1:100
x.sum <- sum(x)
x.mean <- mean(x)
x.sd <- sd(x)
cat(x.sum, x.mean, x.sd, "\n")
```

関数を自分で作ることもできる。自分がよく使う機能をまとめておくことで、プログラムの見通しもよくなったり、機能が再利用しやすくなったり、プログラムコードのメンテナンスしやすくなるなどのメリットが多いので、積極的に利用したい機能である。ひとつの関数はなるべくひとつの機能を果すようにし、画面1枚以内に収まる程度にするのがお勧めである。それが守られないときは、よく考えて、複数の関数に分割することが重要である。

ここでは簡単な関数の例として、DNA配列の相補鎖を計算する関数を定義してみる。
```{r}
complement <- function(x) {
  if (x == "A") {
    return("T")
  } else if (x == "T") {
    return("A")
  } else if (x == "G") {
    return("C")
  } else if (x == "C") {
    return("G")
  } else {
    return("N")
  }
}
complement("A")
complement("G")
complement("*")
```

定義されている関数の使い型を調べるには *help* を利用する。またRの良いところとして、関数の多くに実行例が付属していることである。これを実行するには、*example* を利用する。
#### 関数の使いかたを調べる
````{r}
help(sum)
example(mean)
```

## パッケージを使う
パッケージとは、複数の便利な関数をまとめて提供するものである。R のパッケージは CRAN と Bioconductor から配布されている。パッケージは世界中の開発者によって各々、開発されており、最新の統計手法から、あらゆる実験機器のデータを扱うものまで様々である。特に Bioconductor はバイオインフォマティクス関連のパッケージに特化しており、CRAN よりもソースコードのレビューやドキュメンテーションのルールが厳しく、パッケージが比較的良質に保たれている。

まず、CRANからパッケージをインストールする方法を述べる。パッケージはコマンドから簡単にインストールができ *install.packages* を利用する。
```{r, resluts='hide', cache=TRUE}
install.packages("ggplot2")
```
いろいろメッセージが表示されるが気にする必要はない。インストールが正常に終了していれば、以下のように *library* でパッケージの機能を読み込むことができる。
```{r}
library("ggplot2")
```

次に、Bioconductor からパッケージをダウンロードする。これにはまず専用の関数を *biocLite* を設定する必要がある。ここでは、*biocLite* を設定し、マウス脳トランスクリプトームデータ解析ツールである *BrainStars* パッケージをインストールする。
```{r, cache=TRUE, results='hide'}
source("http://bioconductor.org/biocLite.R")
biocLite("BrainStars")
```
インストールしたパッケージは、CRANパッケージと同様に、*library* でインストールが可能である。ここでは、3つの遺伝子IDを指定し、それらの脳50領域の遺伝子発現量を取り出している。
```{r, cache=TRUE}
library(BrainStars)
ids <- c("1439627_at", "1439631_at", "1439633_at")
my.esets <- getBrainStars(query = ids, type = "expression")
exprs(my.esets)
```

## 簡単な統計解析
Rは、統計解析のための関数を多く持つため、あらゆる統計解析が可能である。ここでは簡単な例として、検定と回帰を取り上げる。

### 検定
ある遺伝子の発現量を測定したとしよう。ここでは、処理群(ここではExp)と対照群(ここではCont)でそれぞれ n = 3, つまり3回の biological replication の発現量を測定してあるとする。これを data frame に格納し、処理、対照群間の平均値の差の検定、ここではT検定を行う。
```{r}
gene <- data.frame(
  sample     = c("Exp", "Exp", "Exp", "Cont", "Cont", "Cont"),
  expression = c(12.8, 13.7, 15.2, 8.0, 7.3, 9.9)
)
t.test(expression ~ sample, data = gene)
```
統計解析を行うときには ***必ず*** グラフを書いて、データの傾向を目視することを忘れてはならない。ここでは boxplot で2群の傾向を可視化する。
```{r fig.width=7, fig.height=6}
plot(expression ~ sample, data = gene)
```

### 回帰
ここでは、一日ごとに遺伝子発現を測定したとする。この遺伝子発現が時間に応じてどのように変化しているか、その傾向を知りたいとする。そこで、一日ごとの発現量を data frame に格納し、回帰分析を行う。
```{r}
gene <- data.frame(
  time       = c(0, 1, 2, 3, 4, 5),
  expression = c(1.8, 3.7, 4.2, 8.0, 10.3, 13.9)
)
gene.lm <- lm(expression ~ time, data = gene)
gene.lm
summary(gene.lm)
```
次に生データと回帰分析によって得られた回帰直線を同時にプロットする。
```{r fig.width=7, fig.height=6}
plot(gene, type = "b", xlim = c(0,6), ylim = c(0,14))
abline(gene.lm, col = "blue")
```

## 次になにを学べばよいか
何度も強調するが自分が必要な機能から学ぶのがよい。ただし最低限Rに実験データを取り込むために、ファイルの入出力の方法を学んでおくとよいであろう。具体的には、*read.csv*, *read.table*, *write.table* などである。またデータ型やデータタイプに関しては主要なものだけを説明しており、Rの機能を網羅しているわけではない。また、*for* ではなく *apply* 族と呼ばれる関数群を使うことや、反復処理ではなくベクトル計算を行うことなどの R らしいコーディングスタイルを学ぶことも重要である。最終的には自分のデータに合せて、Bioconductor, CRAN パッケージの使いかたを覚えるのが次の目標となる。
