---
layout: page
title: "Learning R"
date: 2012-08-13 18:00
comments: true
sharing: true
footer: true
---
RとBioconductorでNGS解析: 1限 Rの基礎

## はじめに
この文章は統合データベース講習会：AJACSみちのく2「RとBioconductorを使ったNGS解析」1限目「Rの基礎」講義資料です。

この文章の著作権は二階堂愛にあります。ファイルのダウンロード、印刷、複製、大量の印刷は自由におこなってよいです。企業、アカデミアに関わらず講義や勉強会で配布してもよいです。ただし販売したり営利目的の集まりで使用してはいけません。ここで許可した行為について二階堂愛に連絡や報告する必要はありません。常に最新版を配布したいので**ネット上での再配布や転載は禁止**します。ネット上でのリンクはご自由にどうぞ。内容についての問い合わせはお気軽にメールしてください。

## 対象
ここでは、本講義を理解する上で知っておきたい、Rの基本的な使いかたについて解説します。対象とするのはプログラミング初心者でRを利用したことがない人が対象です。また、なんとなくRを覚えてきた人が基礎的な知識を整理するためにも役に立つでしょう。

## 準備
***本講義はハンズオンではなく講師の操作を眺めるスタイルですが、一緒に実行してみたい場合は、ご自分のパソコンを持ち込み、以下の準備をしてくることを強くお勧めします。推奨環境は Mac OS X や Linux ですが、Rで実行するプログラムはすべて Windows でも同じように動作します。***

まずは R をインストールします。[http://rstudio.org/](http://rstudio.org/ ) から、利用しているOSに適した RStudio Desktop をインストールします。起動や終了は普通のアプリケーションと同じです。起動したときに3つのペイン(ウィンドウ内にある小窓)が見えますが、左下の console という部分に、Rのプログラムを書き込んでいきます。

#### Proxyの設定
もし http_proxy の設定が必要な場合は、以下のように設定します。

まず Proxy の設定が必要かどうかは以下のコマンドが正常に終了するかどうかで判断できます。
```{r}
source("http://bioconductor.org/biocLite.R")
```
正常に終了しない場合は、~/.Renviron というファイルを作成し中身を
```
http_proxy=http://proxyserver:prot/
```
とします。proxyserverr, prot には、それぞれの機関で提供されている Proxy サーバのアドレスとポート番号を入力します。その後、RStudio を再起動してください。

さらにRのコンソールに
```
options(RCurlOptions = list(proxy = "proxyserver:port"))
```
を入力します。

### R の動作確認
試しに、以下のように入力して同じ結果になれば準備は終了です。ただし、あなたの環境では ## は表示されませんが、それで正常です。この資料では、## が付いていない行が、あなたが入力するコマンドです。## が付いている行は R が出力する結果なので、あなたが入力することはありません。
```{r}
1 + 1    # 足し算
2 * 2    # かけ算
15 / 3   # 割り算
17 %% 3  # 余り
2^2      # べき乗
sqrt(2)  # 平方根
pi       # $\pi$
bmi <- 57.8 / 1.63^2 # Body Mass Index
bmi
```

## 学習範囲
Rを含む、プログラミング言語を理解するときに必要なことは、以下の3つです。

- データ型とデータ構造を知る
- 基本の3つの処理の書きかたを理解する
- 自分が使う便利な機能(関数、パッケージ)を覚える

この文章では、この3つについて簡単に説明します。また、バイオインフォマティクス向けの機能を集めた Bioconductor というソフトウェアパッケージについても紹介します。

## データ型
データ型 (data type) とはデータの形式のことを意味します。例えば数値や文字列、論理型などがあります。
```{r}
x <- c()
x
y <- c(1, 2)
y
z <- c("ATG", "GCG", "CTG", "TTA")
z
b <- c(TRUE, FALSE)
b
```
### データ型の変換
異なるデータ型を行き来したい場合があります。多くのプログラムのエラーはここが原因となるため、データの型の変換方法と、型を調べる方法を理解することは重要です。
```{r}
y <- as.character(y)
y
as.numeric(y)
y
```
### 型の確認
```{r}
mode(1)
mode("A")
is(1)
is("1")
```

## データ構造
前項ではデータを格納する型について解説しました。このデータを集めて、決まった構造でデータを束ねておくのがデータ構造 (data structure) です。プログラミング言語が、決まったデータ構造を提供することで、様々な計算が楽にできるようになります。なぜなら、データの中身が違っても構造が同じことを利用し、汎用的な計算機能(関数)を用意できるからです。また、言語側から考えると、データ構造に対する計算を最適化しておくことができ、ユーザはそのデータ構造さえ使っておけば、高速化などに配慮しなくても良くなります。プログラム言語の善し悪しはこのデータ構造とそれを処理する機能の善し悪しによって決まるとも言えます。Rでは統計解析に向いた様々なデータ構造が用意されています。ここではそのなかでもよく使うデータ構造、*vector*, *list*, *matrix*, *data frame* について述べます。

### vector
*vector* は「1種類のデータ型」からなる「1次元データ」を格納するためのデータ構造です。
```{r}
x <- c(3,2,4,1)
x
```
ここでは、3, 2, 4, 1という1次元の数列を生成して、*x*という変数に格納します。変数とは、生成したデータを保存しておくためのものです。データ型、データ構造、変数の関係が混乱しないよう整理してみてください。この例では、変数が x で、データ構造が *vector*, データ型は *numeric* です。

### list
list は「複数のデータ型」からなる「1次元データ」を格納することができるデータ構造である。例えば文字列型と数値を同時に格納できます。
```{r}
y <- list(3,2,4,1)
y
```

この例では、変数が y で、データ構造が *list*, データ型は *numeric* です。

(発展: リストは1次元データを格納しますが、様々なデータを持てるので、要素に *vector* も持つことができます。)

### matrix
*matrix* は「1種類のデータ型」からなる「2次元データ」を格納するためのデータ構造である。いわゆる行列を表現することができます。
```{r}
z <- matrix(
  c(3,2,1, 2,0,1, 4,5,7, 1,3,3),
  nrow = 3
)
z
```

この例では、変数が z で、データ構造が *matrix*, データ型は *numeric* です。

### data frame
*data frame* は「複数のデータ型」からなる「2次元データ」を格納するためのデータ構造です。Excel などのスプレットシートをイメージすればよいでしょう。数値行列だけを持つ場合は、matrix のほうが data frame より高速です。

(発展: *data.frame* の文字列の列は、*factor* というデータ型の場合があります。factor 型を使えば、統計で言うところのカテゴリカル変数を表現できます。)

```{r}
d <- data.frame(
  first       = c(3,2,1),
  first.base  = c("A", "T", "G"),
  second      = c(4,5,7),
  second.base = c("C", "G", "C")
)
d
```

この例では、変数が d で、データ構造が *data frame*, データ型は *numeric* と *character* です。

### データ構造を確認する
どんなデータ構造を利用しているかを確認する方法を述べます。自分が使っているデータ構造を理解しておかないと、プログラムのエラー(バグ)の原因となります。特定のデータ構造を前提としている機能を使うとき、データ構造や型が異なる場合は、自動的に型や構造を変換したり、エラーを出したりします。
```{r}
is(z)
is(d)
str(d)
```

### データにアクセスする
データ構造にデータを出し入れする方法を示します。行や列の各要素を示す番号を添字 (index) と呼びます。これを使ってデータを取り出したり、代入することが可能です。

まず vector の要素にアクセスする方法を示します。添字は一番左から1,2,3,... となります。プログラミング言語によっては、添字が 0 から始まるものもありますが、R は 1 であることに注意しましょう。
```{r}
x <- c(3,2,4,1)
x[1]
x[1] <- 4
x
x[1:2]
x[1:2] <- c(3,8)
x
```
次に list の要素にアクセスする方法を示します。
```{r}
x <- list(3,2,4,1)
x[[1]]
x[[2]] <- 5
x
```
次は、matrix の要素にアクセスする方法を示します。横方向が行、縦方向が列であり、これは数学の行列と同じです。行と列の方向は漢字の「作り」の最初の画の方向と覚えます。

```{r}
x <- matrix(
  c(3,2,1,2,0,1,4,5,7,1,3,3),
  nrow = 3
)
x[1,]   # 1行目にアクセス
x[,2]   # 2列目にアクセス
x[3,2]  # 3行2列目にアクセス
x[3,2] <- 9 # 3行2列目に9を
x[3,]
```
最後に data frame の要素にアクセスする方法を示します。
```{r}
x <- data.frame(
  first       = c(3,2,1),
  first.base  = c("A", "T", "G"),
  second      = c(4,5,7),
  second.base = c("C", "G", "C")
)
x$first
x$first.base
x$first.base <- c("T", "C", "A")
x$first.base
```

## ワークスペースと作業ディレクトリ
前項で作った変数は、ワークスペースと呼ばれるメモリ上の作業空間に保存されています。よってRを終了するまでメモリ上に保存されていますが、ハードディスクに書き込まれているわけではないので、Rを終了すると消えてしまいます。

解説: メモリとは計算機の頭脳であるCPUがアクセスする記憶装置です。電源を切ったりプログラムが終了するとメモリ内の情報は消えてしまいます。記憶が残るようにするには、ハードディスク(HDD)や、フラッシュメモリ(ソリッドステートドライブ, SSDなど)という装置に保存する必要があります。メモリはHDDやSDDに比べて、データの出し入れが高速なため、計算に必要なデータはいったん、HDDやSSDなどの記憶装置からメモリに読み出して、計算するのが普通です。Rも変数に格納されたデータやコマンド履歴や作成した関数などはメモリ上に蓄えられています。これらをR終了後にも再利用したい場合は、HDDやSSDに書き込む必要があります。

現在のワークスペースの中身を見るには、
```{r}
ls()
```
とします。

このワークスペースをハードディスクに書き込んで、次回 R が起動したときに、まったく同じワークスペースを再現することができます。

```{r}
save.image()
```

また、Rを終了するコマンドを入力するとワークスペースを保存するか聞かれますので、これに y と答えても同じ意味になります。
```
q()
Save workspace image? [y/n/c]: 
```

このファイルはどこに保存されているのでしょうか? これを知るにはまず作業ディレクトリについて知る必要があります。作業ディレクトリとは、Rで作業しているときに、ハードディスク上で基点としている場所のことです。これを知るには、

```{r}
getwd()
```
とします。

作業ディレクトリを変更したい場合は、

```
setwd(ディレクトリ名)
```
とします。

*q* や *save.image* で保存されるファイルは、この作業ディレクトリ上に、.RData というファイル名で保存されます。(ファイル名がピリオドで始まるファイルを、dot file あるいは、隠しファイルと呼び、Windows や Mac では標準の設定では、見ることはできません)

ファイル名を指定して、ワークスペースを保存したい場合は、
```
save.image(file="ファイル名")
```

とします。R では ファイル名.rda という拡張子がよく用いられます。

## 3つの基本的な処理
プログラミング言語は基本的には3つの処理の組み合わせで実行されます。ダイクストラの構造化プログラミング (Structured Programming) では、基本的な処理として3つの処理が挙げられています。

順次: 書かれた順番に処理していく
反復: 条件が満されるまで処理を繰り返す
分岐: 条件が成立する場合は実行する

順次処理については、これまでも示してきた通りなので割愛しますが、Rの場合は文単位 (行ではない) で上から下へと順次処理されます。

次に反復処理について示します。ここでは、*for* を利用した繰り返しの構文を紹介します。
```{r}
ans <- 0
for (i in 1:10) {
  ans <- ans + i
}
ans
```
次に *if* を使って条件によって処理を分岐してみましょう。
```{r}
odd  <- 0
even <- 0
for (i in 1:10) {
  if (i %% 2 == 0) {
    even <- even + i
  } else {
    odd <- odd + i
  }   
}
cat(even, odd, "\n")
```

### 関数
関数 (function) とは、便利な機能のひとかたまりにしたものです。プログラミング言語には様々な関数が定義されており、この関数の豊富さが言語の使い易さに深く関わっています。Rでは文字や数値の処理だけでなく、統計処理のための便利な関数が多数用意されています。関数は膨大にあるので、まず自分の使う関数だけを覚えておき、必要に応じてリファレンスや Web検索などで必要な関数を調べるのがお勧めです。

簡単な統計量を計算する関数を紹介します。
```{r}
x <- 1:100
x.sum <- sum(x)
x.mean <- mean(x)
x.sd <- sd(x)
cat(x.sum, x.mean, x.sd, "\n")
```

関数を自分で作ることもできます。自分がよく使う機能をまとめておくことで、プログラムの見通しもよくなったり、機能が再利用しやすくなったり、プログラムコードのメンテナンスしやすくなるなどのメリットが多いので、積極的に利用したい機能です。

関数を作るコツは、ひとつの関数はなるべくひとつの機能を果すようにし、画面1枚以内に収まる程度にすることです。れが守られないときは、よく考えて、複数の関数に分割することが重要です。

ここでは簡単な関数の例として、DNA配列の相補鎖を計算する関数を定義してみましょう。
```{r}
complement <- function(x) {
  if (x == "A") {
    return("T")
  } else if (x == "T") {
    return("A")
  } else if (x == "G") {
    return("C")
  } else if (x == "C") {
    return("G")
  } else {
    return("N")
  }
}
complement("A")
complement("G")
complement("*")
```

定義されている関数の使い型を調べるには *help* を利用します。Rの良いところとして、関数の多くに実行例が付属していることです。これを実行するには、*example* を利用します。
#### 関数の使いかたを調べる
````{r}
help(sum)
example(mean)
```

## パッケージを使う
パッケージとは、複数の便利な関数をまとめて提供するものです。R のパッケージは CRAN と Bioconductor から配布されています。パッケージは、世界中の開発者によって各々、開発されており、最新の統計手法や、様々な実験機器データを扱うパッケージなど様々です。特に Bioconductor はバイオインフォマティクス関連のパッケージに特化しており、CRAN よりもソースコードのレビューやドキュメンテーションのルールが厳しく、パッケージが比較的良質に保たれています。

まず、CRANからパッケージをインストールする方法を述べます。パッケージはコマンドから簡単にインストールができ *install.packages* を利用します。
```{r, resluts='hide', cache=TRUE}
install.packages("ggplot2")
```
インストールが正常に終了していれば、以下のように *library* でパッケージの機能を読み込むことができます。
```{r}
library("ggplot2")
```

次に、Bioconductor からパッケージをダウンロードします。これにはまず専用の関数を *biocLite* を設定する必要します。ここでは、*biocLite* を設定し、マウス脳トランスクリプトームデータ解析ツールである *BrainStars* パッケージをインストールしてみます。

いろいろメッセージが表示されるが気にする必要はありません。
```{r, cache=TRUE, results='hide'}
source("http://bioconductor.org/biocLite.R")
biocLite("BrainStars")
```

***Proxy*** がある場合は、以下のような設定を先にしておきます。
```{r}
options(RCurlOptions = list(proxy="proxy.l2.med.tohoku.ac.jp:8080"))
```

インストールしたパッケージは、CRANパッケージと同様に、*library* で使うことができます。ここでは、3つの遺伝子IDを指定し、それらの脳50領域の遺伝子発現量を取り出しています。
```{r, cache=TRUE}
library(BrainStars)
ids <- c("1439627_at", "1439631_at", "1439633_at")
my.esets <- getBrainStars(query = ids, type = "expression")
exprs(my.esets)
```

## 簡単な統計解析
Rは、統計解析のための関数を多く持つため、あらゆる統計解析が可能です。ここでは簡単な例として、検定と回帰を取り上げます。

### 検定
ある遺伝子の発現量を測定したとします。ここでは、処理群(ここではExp)と対照群(ここではCont)でそれぞれ n = 3, つまり3回の biological replication の発現量を測定してあるとします。これを data frame に格納し、処理、対照群間の平均値の差の検定、ここではT検定を行なってみます。
```{r}
gene <- data.frame(
  sample     = c("Exp", "Exp", "Exp", "Cont", "Cont", "Cont"),
  expression = c(12.8, 13.7, 15.2, 8.0, 7.3, 9.9)
)
t.test(expression ~ sample, data = gene)
```
統計解析を行うときには ***必ず*** グラフを書いて、データの傾向を目視することを忘れてはなりません。プログラムのバグを避けたり、データの不具合や入れ違いに気付くためには不可欠だからです。統計処理をしてしまうと、それに気付くことは非常に困難です。

ここでは boxplot で2群の傾向を可視化しています。
```{r fig.width=7, fig.height=6}
plot(expression ~ sample, data = gene)
```

### 回帰
ここでは、一日ごとに遺伝子発現を測定したとしましょう。この遺伝子発現が時間に応じてどのように変化しているか、その傾向を知りたいとします。そこで、一日ごとの発現量を data frame に格納し、回帰分析を行ってみます。
```{r}
gene <- data.frame(
  time       = c(0, 1, 2, 3, 4, 5),
  expression = c(1.8, 3.7, 4.2, 8.0, 10.3, 13.9)
)
gene.lm <- lm(expression ~ time, data = gene)
gene.lm
summary(gene.lm)
```
次に生データと回帰分析によって得られた回帰直線を同時にプロットします。
```{r fig.width=7, fig.height=6}
plot(gene, type = "b", xlim = c(0,6), ylim = c(0,14))
abline(gene.lm, col = "blue")
```

## 次になにを学べばよいか
何度も強調しますが、まず自分が必要な機能から学ぶのがよいです。ただし最低限Rに実験データを取り込むために、ファイルの入出力の方法を学んでおくとよいでしょう。具体的には、*read.csv*, *read.table*, *write.table* などです。

またデータ型やデータタイプに関しては主要なものだけを説明しており、Rの機能を網羅しているわけではありません。特に factor 型を理解しておくと良いでしょう。また、*for* ではなく *apply* 族と呼ばれる関数群を使うことや、反復処理ではなくベクトル計算を行うことなどの R らしいコーディングスタイルを学ぶことも重要です。

最終的には自分のデータに合せて、Bioconductor, CRAN パッケージの使いかたを覚えるのが次の目標となります。この講義では、RNA-seq, ChIP-seq を例に、Bioconductor の使い方を解説していきます。

## 練習問題
### 問題1
1から順に数字を表示しなさい。ただしその数が3で割り切れるならは数字のかわりに Fizz と、5で割り切れるなら Buzz と、3でも5でも割り切れる場合は FizzBuzz と表示しなさい (いわゆる FizzBuzz 問題と呼ばれており、プログラマならば、なにも参考にせずに、2分で解けなければならないと言われている)。

### 問題2
問題1を条件分岐を使わずに解きなさい。

### 問題3
以下のようにすると、Rに組み込まれているデータフレーム iris を読み込むことができる。
```r
data(iris)
```

この *iris* の1から4列の各列の標準偏差を *for* を使って求めなさい。

### 問題4
問題2で利用した *iris* の列ごとの平均を *for* を使って求めなさい。

### 問題5
問題2を *for* を用いずに一行で求めなさい。ヒント: *sapply* あるいは、*colMeans* を *help* で調べる。

### 問題6
問題2で利用した *iris* の1から4列の各列の標準偏差を *for* を用いずに、sapply 関数を使って求めなさい。

### 問題7
「パッケージを使う」のパートで出てきた *exprs(my.esets)* を *boxplot* 関数を用いてプロットせよ。

## 発展問題
ここで解説したRプログラミングの知識がすでにあるという人は、講義を聞かずに以下の問題を解いていてもよい。ウェブ検索を駆使して答えよ。

### 初級
* 前項の練習問題すべてを、ヘルプや検索を用いずに、20分以内に解け
* 講義資料中にある「DNA配列の相補鎖を計算する関数」を、関数を自作せずに、Rに組み込まれているたったひとつの関数で実現せよ。
* 練習問題1の結果をファイルを出力せよ。ただし一行ごとにひとつの数字または文字列を表示せよ。

### 中級
* lapply, apply, sapply の違いについて述べよ。
* Rに組み込みこまれている apply 族関数と plyr package で提供される関数について比較し説明せよ。
* multicore package を利用して、練習問題1をマルチコアを使った並列計算するコードに直せ。

### 上級
* 問題1をS3, S4, R5 オブジェクト指向で実装し直せ。
* Rのスコープについて解説せよ。ヒント: (環境、レキシカルスコープ)
* 総称関数とはなにか。*summary* か *plot* を例に説明せよ。
* 上記の回答をすべて、R markdown で執筆し、[RPubs](http://www.rpubs.com/) にアップロードせよ。


## 実行環境
```{r}
sessionInfo()
```
